### 避免在临界区返回指针或引用
> 在临界区返回共享数据的指针或引用，会导致线程可以不使用互斥锁就可以访问共享数据

### 避免在临界区中将共享数据的指针或引用传递到三方函数中
> 三方函数可能在函数体内将共享数据的指针存储到未知的位置。

### 死锁产生原因
> 1. 不可抢占（锁或资源）
> 2. 请求并保持
> 3. 互斥访问
> 4. 循环等待
> ```bash
> 循环等待锁
> 多个线程循环等待对方结束再进行下一步操作
> ``` 

### 死锁解决办法（in c++）
> 1. 若是有多个锁引起的死锁，可以让线程以固定的顺序加锁
> 2. 在c++11中使用标准库的`std::locak(mutex1, mutex2,...)` 对多个锁同时上锁
> 3. 在拥有一个锁时，不要尝试去申请其它的锁,避免嵌套锁
> 4. 

